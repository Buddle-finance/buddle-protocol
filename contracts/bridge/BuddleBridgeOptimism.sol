// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@eth-optimism/contracts/L1/messaging/L1StandardBridge.sol";
import "@eth-optimism/contracts/L1/messaging/L1CrossDomainMessenger.sol";


contract BuddleBridgeOptimism {
    using SafeERC20 for IERC20;

    address constant BASE_TOKEN_ADDRESS = address(0);

    address messenger; // Optimism L1 cross domain messenger address
    address tokenBridge; // Optimism L2 standard bridge
    address addressManager; // Optimism address manager

    address srcContract; // Address of deployed Source Side contract on Optimism
    address destContract; // Address of deployed Destination Side contract on Optimism
    address admin; // Address of the admin which can change the tokenMap mapping
    mapping(address => address) tokenMap; // Mapping of l2 token address to l1 token address

    /** Modifiers */

    /**
     * Checks whether the caller is the admin or not
     */
    modifier onlyAdmin {
        require(msg.sender == admin, "You are not admin!");
        _;
    }

    /**
     * Checks that _source is not already mapped
     */
    modifier emptyPair(address _l2TokenAddr) {
        require(tokenMap[_l2TokenAddr] == address(0), "Source is already paired!");
        _;
    }

    /**
     * Checks whether the contract is initialized
     */
    modifier checkInitialization() {
        require(messenger != address(0), "Contract not initialized yet.");
        _;
    }

    /** External onlyAdmin functions */

    /**
     * Initialize the contract with state variables
     * @param _messenger The address of the L1 Cross Domain Messenger Contract
     * @param _tokenBridge The address of the L2 Standard Token Bridge
     * @param _addressManager The address of the Address Manager
     * @param _admin The address of the admin for this contract
     */
    function initialize(
        address _messenger, 
        address _tokenBridge, 
        address _addressManager,
        address _admin
    ) external {
        require(messenger == address(0), "Contract already initialized!");
        messenger = _messenger;
        tokenBridge = _tokenBridge;
        addressManager = _addressManager;
        admin = _admin;
    }

    /**
     * Set the source and destination side contracts for the respective L2 chain
     * @param _src The address of the deployed Source Side contract
     * @param _dest The address of the deployed Destination Side contract
     */
    function setContracts(
        address _src,
        address _dest
    ) external onlyAdmin checkInitialization {
        srcContract = _src;
        destContract = _dest;
    }

    /**
     * Add a token mapping to the contract
     */
    function addTokenAddress(
        address _l2TokenAddress,
        address _l1TokenAddress 
    ) external onlyAdmin emptyPair(_l2TokenAddress) checkInitialization {
        tokenMap[_l2TokenAddress] = _l1TokenAddress;
    }

    /** External Functions */

    /**
     * Claim the bounty for the current pool. A ticket must be emitted prior to this function.
     * @param _ticket The ticket generated by the source L2 contract
     * @param _tokens List of tokens (L2 addresses) supported by Buddle Source
     * @param _amounts List of amounts corresponding to _tokens
     * @param _firstIdForTicket The first transfer id included in _ticket
     * @param _lastIdForTicket The last transfer id included in _ticket
     * @param stateRoot State root emitted with the corresponding _ticket
     */
    function claimBounty(
        bytes32 _ticket,
        address[] memory _tokens,
        uint256[] memory _amounts,
        uint256 _firstIdForTicket,
        uint256 _lastIdForTicket,
        bytes32 stateRoot
    ) external payable {
        L1CrossDomainMessenger _messenger;
        _messenger.initialize(addressManager);

        L1StandardBridge _bridge;
        _bridge.initialize(messenger, tokenBridge);

        _messenger.sendMessage(
            srcContract,
            abi.encodeWithSignature(
                "confirmTicket(bytes32,address[],uint256[],uint256,uint256,bytes32,address)",
                _ticket, _tokens, _amounts, _firstIdForTicket, 
                 _lastIdForTicket, stateRoot, msg.sender
            ),
            1000000
        );

        for(uint i=0; i < _tokens.length; i++) {
            if(_tokens[i] == BASE_TOKEN_ADDRESS) {
                require(msg.value >= _amounts[i], "Insufficient funds sent");
                _bridge.depositETHTo(destContract, 1000000, bytes(""));
            } else {
                IERC20 token = IERC20(_tokens[i]);
                require(token.balanceOf(msg.sender) >= _amounts[i], "Insufficient funds sent");
                token.approve(messenger, _amounts[i]);
                
                _bridge.depositERC20To(
                    tokenMap[_tokens[i]], // L1 token address
                    _tokens[i], // L2 token address
                    destContract, // to address
                    _amounts[i], // amount to be transferred
                    1000000, // Gas limit 
                    bytes("") // Data empty
                );
            }
        }

        _messenger.sendMessage(
            destContract,
            abi.encodeWithSignature(
                "approveSrc(bytes32)",
                stateRoot
            ),
            1000000
        );
    }
}